From 6ca96a4f6c7ee6174b0b67b7e9f8b37bcad28805 Mon Sep 17 00:00:00 2001
From: Igor Mammedov <imammedo@redhat.com>
Date: Mon, 1 Aug 2016 08:12:18 +0200
Subject: [PATCH 78/99] exec: Set cpu_index only if it's not been explictly set

RH-Author: Igor Mammedov <imammedo@redhat.com>
Message-id: <1470039143-24450-74-git-send-email-imammedo@redhat.com>
Patchwork-id: 71689
O-Subject: [RHEV-7.3 qemu-kvm-rhev PATCH 73/78] exec: Set cpu_index only if it's not been explictly set
Bugzilla: 1087672
RH-Acked-by: Marcel Apfelbaum <marcel@redhat.com>
RH-Acked-by: David Gibson <dgibson@redhat.com>
RH-Acked-by: Eduardo Habkost <ehabkost@redhat.com>

It keeps the legacy behavior for all users that doesn't care
about stable cpu_index value, but would allow boards that
would support device_add/device_del to set stable cpu_index
that won't depend on order in which cpus are created/destroyed.

While at that simplify cpu_get_free_index() as cpu_index
generated by USER_ONLY and softmmu variants is the same
since none of the users support cpu-remove so far, except
of not yet released spapr/x86 device_add/delr, which
will be altered by follow up patches to set stable
cpu_index manually.

Signed-off-by: Igor Mammedov <imammedo@redhat.com>
Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
(cherry picked from commit a07f953ef4ef48058c24fb50b49e6fa28bf5f5f4)
Signed-off-by: Miroslav Rezanina <mrezanin@redhat.com>
---
 exec.c            | 44 ++++++--------------------------------------
 include/qom/cpu.h |  2 ++
 qom/cpu.c         |  2 +-
 3 files changed, 9 insertions(+), 39 deletions(-)

diff --git a/exec.c b/exec.c
index 79db83d..ffd65af 100644
--- a/exec.c
+++ b/exec.c
@@ -595,30 +595,7 @@ AddressSpace *cpu_get_address_space(CPUState *cpu, int asidx)
 }
 #endif
 
-#ifndef CONFIG_USER_ONLY
-static DECLARE_BITMAP(cpu_index_map, MAX_CPUMASK_BITS);
-
-static int cpu_get_free_index(Error **errp)
-{
-    int cpu = find_first_zero_bit(cpu_index_map, MAX_CPUMASK_BITS);
-
-    if (cpu >= MAX_CPUMASK_BITS) {
-        error_setg(errp, "Trying to use more CPUs than max of %d",
-                   MAX_CPUMASK_BITS);
-        return -1;
-    }
-
-    bitmap_set(cpu_index_map, cpu, 1);
-    return cpu;
-}
-
-static void cpu_release_index(CPUState *cpu)
-{
-    bitmap_clear(cpu_index_map, cpu->cpu_index, 1);
-}
-#else
-
-static int cpu_get_free_index(Error **errp)
+static int cpu_get_free_index(void)
 {
     CPUState *some_cpu;
     int cpu_index = 0;
@@ -629,12 +606,6 @@ static int cpu_get_free_index(Error **errp)
     return cpu_index;
 }
 
-static void cpu_release_index(CPUState *cpu)
-{
-    return;
-}
-#endif
-
 void cpu_exec_exit(CPUState *cpu)
 {
     CPUClass *cc = CPU_GET_CLASS(cpu);
@@ -648,8 +619,7 @@ void cpu_exec_exit(CPUState *cpu)
 
     QTAILQ_REMOVE(&cpus, cpu, node);
     cpu->node.tqe_prev = NULL;
-    cpu_release_index(cpu);
-    cpu->cpu_index = -1;
+    cpu->cpu_index = UNASSIGNED_CPU_INDEX;
     cpu_list_unlock();
 
     if (cc->vmsd != NULL) {
@@ -663,7 +633,7 @@ void cpu_exec_exit(CPUState *cpu)
 void cpu_exec_init(CPUState *cpu, Error **errp)
 {
     CPUClass *cc ATTRIBUTE_UNUSED = CPU_GET_CLASS(cpu);
-    Error *local_err = NULL;
+    Error *local_err ATTRIBUTE_UNUSED = NULL;
 
     cpu->as = NULL;
     cpu->num_ases = 0;
@@ -687,11 +657,9 @@ void cpu_exec_init(CPUState *cpu, Error **errp)
 #endif
 
     cpu_list_lock();
-    cpu->cpu_index = cpu_get_free_index(&local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
-        cpu_list_unlock();
-        return;
+    if (cpu->cpu_index == UNASSIGNED_CPU_INDEX) {
+        cpu->cpu_index = cpu_get_free_index();
+        assert(cpu->cpu_index != UNASSIGNED_CPU_INDEX);
     }
     QTAILQ_INSERT_TAIL(&cpus, cpu, node);
     cpu_list_unlock();
diff --git a/include/qom/cpu.h b/include/qom/cpu.h
index aa1d19c..6f71918 100644
--- a/include/qom/cpu.h
+++ b/include/qom/cpu.h
@@ -851,4 +851,6 @@ extern const struct VMStateDescription vmstate_cpu_common;
     .offset = 0,                                                            \
 }
 
+#define UNASSIGNED_CPU_INDEX -1
+
 #endif
diff --git a/qom/cpu.c b/qom/cpu.c
index 4b067ad..ed420f8 100644
--- a/qom/cpu.c
+++ b/qom/cpu.c
@@ -341,7 +341,7 @@ static void cpu_common_initfn(Object *obj)
     CPUState *cpu = CPU(obj);
     CPUClass *cc = CPU_GET_CLASS(obj);
 
-    cpu->cpu_index = -1;
+    cpu->cpu_index = UNASSIGNED_CPU_INDEX;
     cpu->gdb_num_regs = cpu->gdb_num_g_regs = cc->gdb_num_core_regs;
     qemu_mutex_init(&cpu->work_mutex);
     QTAILQ_INIT(&cpu->breakpoints);
-- 
1.8.3.1

